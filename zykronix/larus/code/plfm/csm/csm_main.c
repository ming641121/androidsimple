/*====================================================================
 * Copyright (C) 2006, All Rights Reserved, by
 * Ahoya Networks, Inc. San Jose, CA.
 *
 * Abstract:
 *    This file contains the routines of CSM Data Base
 *    Management for redundancy
 *
 * Note:
 *
 * Author(s):
 *
 *====================================================================
 * $Id: csm_main.c,v 1.10 2006/10/03 05:19:19 cvsshuming Exp $
 * $Source: /cvsroot/larus5820/code/plfm/csm/csm_main.c,v $
 */

#include <stdio.h>
#include <string.h>
#include "sys_os.h"
#include "trapdef.h"
#include "trap_if.h"

#include "csm_if.h"
#include "csm_events.h"

#define    CSM_TASK_PRI    10


/*
 *====================================================================
 *=                              Global                              =
 *====================================================================
 */

CSM_CB_s	 csmCb;
BOOL_t       dbgCsm = TRUE;

/*
 *====================================================================
 *=                               Local                              =
 *====================================================================
 */

/*static    SIW_TID_t     taskId; */
/*static*/    SIW_MQID_t    msgQId;

/*
 *====================================================================
 *=                              Routine                             =
 *====================================================================
 */

/*========================================================================
 * Function:     CsmProcessQueue
 *
 * Description:  ISR to handle the interrupt generated by line 3 to 7
 *
 * In Parms:     none
 * Out Parms:    none
 *
 * Returns:      OK if success, ERROR otherwise
 */
void 
CsmProcessQueue (void)
{
    MSG_t			* msgPtr;
    MSG_BUF_HDR_t	siwMsg;
	EVENT_LOG_HDR_t * evtLogHdr = NULL;
    /*char			* evtPtr;*/
	U8_t			lineIndx;
    /*char          trapBuf[512];*/ 

	/*printf(".");*/
    /* See if there is any Trap message in the queue */
    if (SiwMsgQReceive(MSGQ2CSM, &siwMsg,
	/*if (SiwMsgQReceive(msgQId, &siwMsg,*/
        sizeof(MSG_BUF_HDR_t), NO_WAIT) > 0)
    {
        msgPtr = (MSG_t *) siwMsg.msgBufPtr;
        printf("SiwMsgQReceive,	msgPtr = 0x%x\n", (U32_t)msgPtr);
        
        if (msgPtr)
        {     
        	evtLogHdr = (EVENT_LOG_HDR_t *)&msgPtr->data[0];
			if (evtLogHdr->slotNo == 17) {
				lineIndx = 0;
			} else if (evtLogHdr->slotNo == 18)	{
				lineIndx = 1;
			} else if (evtLogHdr->slotNo == 20)	{
				lineIndx = 5;	  /* Oscillator or Rb - A */
			} else if (evtLogHdr->slotNo == 21)	{
				lineIndx = 6;	  /* Oscillator or Rb - B */
			} else if (evtLogHdr->slotNo == 23)	{
				if (evtLogHdr->portNo == 6) {
					lineIndx = 2;
				} else if (evtLogHdr->portNo == 1) {
					lineIndx = 3;
				} else if (evtLogHdr->portNo == 2) {
					lineIndx = 4;
				} else {
					printf("%s unsupported portNo = %d\n", __FUNCTION__, evtLogHdr->portNo);
					return;
				}
			} else {
				printf("%s unsupported slotNo = %d\n", __FUNCTION__, evtLogHdr->slotNo);
				return;
			}
#if 0
                evtLogHdr->alarmId
            evtLogHdr->shelf
            evtLogHdr->slotNo
            evtLogHdr->portNo
            evtLogHdr->severity
#endif
            switch (evtLogHdr->alarmId)
            {	  
				case stsLinkDown_TRAP:
                    if (dbgCsm)
                        printf("CSM:LinkDown_TRAP trap received on lineIndex=%d\n",lineIndx);

					if (lineIndx < 5) {
						CsmClockInputDown(lineIndx);
					} else {
						CsmClockRefDown(lineIndx);
					}
					
					break;
				case stsLinkUp_TRAP:
                    if (dbgCsm)
                        printf("CSM:LinkUp_TRAP trap received on lineIndex=%d\n",lineIndx);

					if (lineIndx < 5) {
						CsmClockInputUp(lineIndx);
					} else {
						CsmClockRefUp(lineIndx);
					}
					
					break;
                default:
					printf("%s unknown alarmId=%d\n", __FUNCTION__, evtLogHdr->alarmId); 
                    break;
            }

            /* Free the message */
            SiwFreeMem (msgPtr);
        }
    }
}

/*========================================================================
 * Function:     CsmTask
 *
 * Description:  CSM main task routine
 *
 * In Parms:     none
 * Out Parms:    none
 *
 * Returns:      OK if success, ERROR otherwise
 */
void
CsmTask (void)
{
    CSM_FUNC_TRACE0(CsmTask); 

    /* first thing that you do */
    CsmInit();

    /* Send the ACK */
    pendSysReady();

#if 0
    CsmInitSnmpSt();

    /* verify */
    if (dbgCsm)
        printf("CSM: This card 0x%x is active\n", SiwMySlotNo());

    /* Init the DBM */
    if ( (ret=CsmDbmInit()) != OK) 
    {
        printf("CSM: CsmDbmInit failed: ret=0x%x\n", ret);
        return;
    }


    /* start creating the queues and the tasks */
    msgQId = SiwMsgQCreate(10, sizeof(MSG_BUF_HDR_t), 
            SIW_MSG_PRI_NORMAL, "CSM_Q");

    if(msgQId == SIW_INVALID_MQID) {
        printf("Can't Create queue for CSM\n");
        return;
    }
    if (dbgCsm)
        printf("CSM qid (0x%x)\n", (U32_t) msgQId);
#endif /* 0 */
   
    /* Init Data Base for persistance */
	CsmDbInit();

    /* Wait for other tasks to finish their persistant data recovery */
	pendDbmReady();

    SiwTaskInitAck(OK);

    /* Register Event Trap */
    if (dbgCsm)
        printf("CSM: EventTrapRegister\n");

    SiwTaskDelay(300);

    /* Register the trap event required by CSM */
    if (EventTrapRegister(stsLinkUp_TRAP, MSGQ2CSM, FALSE) != OK)
    {
        printf("ERR: CSM EventTrapRegister cardActive_TRAP\n");
    }
    
    if (EventTrapRegister(stsLinkDown_TRAP, MSGQ2CSM, FALSE) != OK)
    {
        printf("ERR: CSM EventTrapRegister cardServiceSwitched_TRAP\n");
    }

    SiwTaskDelay(500);

    /* Start processing */
    if (dbgCsm)
        printf("CSM: DbmInit is complete\n");

    /* main processing loop */
    while (TRUE) {
	   CsmProcessQueue();
	   CsmCheckClkSrc();
       /* sleep */
       SiwTaskDelay(300);
    }
	/* should never happended */
    CSM_DBG_EXIT; 
}

#if 0
/*========================================================================
 * Function:     CsmMainEntry
 *
 * Description:  CSM main routine
 *
 * In Parms:     none
 * Out Parms:    none
 *
 * Returns:      OK if success, ERROR otherwise
 */
CSM_RET_e
CsmMainEntry (void)
{
    CSM_RET_e       ret = CSM_RET_OK;
    SIW_PRIORITY_t  pri;
    SIW_TASKINFO_t  info;
	STATUS_t        taskStatus;

	printf("%s called\n", __FUNCTION__);
    /* Set priority for forward and backward threads */
    pri.applId     = SIW_APPL_SW;
    pri.prioGroup  = SIW_PRI_GRP_NORMAL;
    pri.priority   = CSM_TASK_PRI;

    /* Set task info */
    info.stackSize = SIW_DEFAULT_STACK;
    info.arg1      = 0x0;
    info.arg2      = 0x0;
    info.arg3      = 0x0;
    info.arg4      = 0x0;
    info.waitAck   = WAIT_FOREVER;
    info.entryPt   = (FUNC_PTR_t) CsmTask;

    /* start creating the queues and the tasks */
    msgQId = SiwMsgQCreate(10, sizeof(MSG_BUF_HDR_t), 
            SIW_MSG_PRI_NORMAL, "CSM_Q");

    if(msgQId == SIW_INVALID_MQID) {
        printf("Can't Create queue for CSM\n");
        return -1;
    }
    if (dbgCsm)
        printf("CSM qid (0x%x)\n", (U32_t) msgQId);
    
    /* spawn Read task queue thread */
    taskId = SiwTaskSpawn("tCSM", &pri, &info,
                       SIW_RECV_LOG_ERROR,
                       SIW_RECV_LOG_ERROR,
                       NULL,
                       &taskStatus);

    if(SIW_INVALID_TID == taskId) {
        printf("Can't create CSM task.. EXITING ....... \n");
        return -1;
    }

    if (dbgCsm)	{
        printf("CSM taskId(%d), status(%d)\n", 
            (U32_t) taskId, (U32_t ) taskStatus);
	}

    return (ret);
}
#endif /* 0 */
