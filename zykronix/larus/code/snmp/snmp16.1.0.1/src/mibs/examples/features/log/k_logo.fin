/*
 *
 * Copyright (C) 1992-2003 by SNMP Research, Incorporated.
 *
 * This software is furnished under a license and may be used and copied
 * only in accordance with the terms of such license and with the
 * inclusion of the above copyright notice. This software or any other
 * copies thereof may not be provided or otherwise made available to any
 * other person. No title to and ownership of the software is hereby
 * transferred.
 *
 * The information in this software is subject to change without notice
 * and should not be construed as a commitment by SNMP Research, Incorporated.
 *
 * Restricted Rights Legend:
 *  Use, duplication, or disclosure by the Government is subject to
 *  restrictions as set forth in subparagraph (c)(1)(ii) of the Rights
 *  in Technical Data and Computer Software clause at DFARS 252.227-7013;
 *  subparagraphs (c)(4) and (d) of the Commercial Computer
 *  Software-Restricted Rights Clause, FAR 52.227-19; and in similar
 *  clauses in the NASA FAR Supplement and other corresponding
 *  governmental regulations.
 *
 */

/*
 *                PROPRIETARY NOTICE
 *
 * This software is an unpublished work subject to a confidentiality agreement
 * and is protected by copyright and trade secret law.  Unauthorized copying,
 * redistribution or other use of this work is prohibited.
 *
 * The above notice of copyright on this source code product does not indicate
 * any actual or intended publication of such source code.
 */


/*
 * Arguments used to create this file:
 * -agent -o logo 
 */

/*
 * File Description:
 */

#include "sr_conf.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include "sr_snmp.h"
#include "comunity.h"
#include "v2clssc.h"
#include "sr_trans.h"
#include "context.h"
#include "method.h"
#include "makevb.h"
#include "mibout.h"
#include "sr_proto.h"
#include "sr_type.h"

#ifndef SR_DEBUG
#define SR_DEBUG
#endif /* SR_DEBUG */

#include "diag.h"
#include "logq.h"

#ifdef SR_FILENAME
SR_FILENAME
#undef SR_FILENAME
#endif /* SR_FILENAME */

int
#ifndef PER_FILE_INIT
k_initialize()
#else /* PER_FILE_INIT */
k_logo_initialize()
#endif /* PER_FILE_INIT */
{
    SR_INT32 log_level;

    DPRINTF((APWARN, "Changing log handler function to QueueLogMessage()\n"));
    SetLogFunction(QueueLogMessage);   /* queue messages from the Agent */
    SetLogUserData((void *)20);        /* keep twenty messages in the queue */

    log_level = GetLogLevel();

    if (log_level & APCONFIG) {
	DPRINTF((APWARN, "Turning off APCONFIG for QueueLogMessage()\n"));
	log_level &= ~APCONFIG;
    }

    /*
     * Turn off the log levels of messages that are generated for
     * each received packet.  If these messages are put into the
     * queue, any attempt to use SNMP Get requests to retrieve the
     * logTable will flood the queue.
     */

    if (log_level & APTRACE) {
	DPRINTF((APWARN, "Turning off APTRACE for QueueLogMessage()\n"));
	log_level &= ~APTRACE;
    }
    if (log_level & APPACKET) {
	DPRINTF((APWARN, "Turning off APPACKET for QueueLogMessage()\n"));
	log_level &= ~APPACKET;
    }
    if (log_level & APACCESS) {
	DPRINTF((APWARN, "Turning off APACCESS for QueueLogMessage()\n"));
	log_level &= ~APACCESS;
    }
    if (log_level == 0) {
	DPRINTF((APWARN, "Warning: log level is zero\n"));
    }

    SetLogLevel(log_level);
    TestLogMessages();
    return 1;
}

int
#ifndef PER_FILE_INIT
k_terminate()
#else /* PER_FILE_INIT */
k_logo_terminate()
#endif /* PER_FILE_INIT */
{
    return 1;
}

srLogEntry_t *
k_srLogEntry_get(int serialNum, ContextInfo *contextInfo,
                 int nominator,
                 int searchType,
                 SR_INT32 srLogIndex)
{
    LogEntry *found = NULL;
    static srLogEntry_t srLogEntryData;
    unsigned char LogLevelBits[4];

    if (srLogEntryData.srLogProgram) {
	FreeOctetString(srLogEntryData.srLogProgram);
	srLogEntryData.srLogProgram = NULL;
    }
    if (srLogEntryData.srLogSrcFile) {
	FreeOctetString(srLogEntryData.srLogSrcFile);
	srLogEntryData.srLogSrcFile = NULL;
    }
    if (srLogEntryData.srLogMessage) {
	FreeOctetString(srLogEntryData.srLogMessage);
	srLogEntryData.srLogMessage = NULL;
    }
    srLogEntryData.srLogIndex = srLogIndex;
    found = SearchLogMessageQueue(searchType, &srLogEntryData.srLogIndex);

    if (found) {
	LogLevelBits[0] = (unsigned char)((0xff000000 & found->LogLevel) >> 24);
	LogLevelBits[1] = (unsigned char)((0x00ff0000 & found->LogLevel) >> 16);
	LogLevelBits[2] = (unsigned char)((0x0000ff00 & found->LogLevel) >> 8);
	LogLevelBits[3] = (unsigned char)((0x000000ff & found->LogLevel));
	srLogEntryData.srLogLevel = MakeOctetString(LogLevelBits, 4);
	srLogEntryData.srLogTime = found->timestamp;
	if (found->progname) {
	    srLogEntryData.srLogProgram = MakeOctetStringFromText(found->progname);
	}
	if (found->filename) {
	    srLogEntryData.srLogSrcFile = MakeOctetStringFromText(found->filename);
	}
	srLogEntryData.srLogSrcLine = found->linenum;
	if (found->message) {
	    srLogEntryData.srLogMessage = MakeOctetStringFromText(found->message);
	}
	SET_ALL_VALID(srLogEntryData.valid);
	return(&srLogEntryData);
    }
    else {
	return(NULL);
    }
}

